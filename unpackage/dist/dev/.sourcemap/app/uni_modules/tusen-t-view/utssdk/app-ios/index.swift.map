{"version":3,"sources":["uni_modules/tusen-t-view/utssdk/app-ios/index.vue"],"sourcesContent":["\n\n\n\n\n  /**\n   * 引用 iOS 系统库\n   * [可选实现，按需引入]\n   */\n  import {\n    UIButton,\n    UIControl\n  } from \"UIKit\"\n\n  /**\n   * 引入三方库\n   * [可选实现，按需引入]\n   *\n   * 在 iOS 平台引入三方库有以下两种方式：\n   * 1、通过引入三方库framework 或者.a 等方式，需要将 .framework 放到 ./Frameworks 目录下，将.a 放到 ./Libs 目录下。更多信息[详见](https://uniapp.dcloud.net.cn/plugin/uts-plugin.html#ios-平台原生配置)\n   * 2、通过 cocoaPods 方式引入，将要引入的 pod 信息配置到 config.json 文件下的 dependencies-pods 字段下。详细配置方式[详见](https://uniapp.dcloud.net.cn/plugin/uts-ios-cocoapods.html)\n   *\n   * 在通过上述任意方式依赖三方库后，使用时需要在文件中 import:\n   * 示例：import { LottieAnimationView, LottieAnimation, LottieLoopMode\t} from 'Lottie'\n   */\n\n  /**\n   * UTSiOS、UTSComponent 为平台内置对象，不需要 import 可直接调用其API，[详见](https://uniapp.dcloud.net.cn/uts/utsios.html)\n   */\n  import { UTSComponent } from \"DCloudUTSFoundation\"\n\n  //原生提供以下属性或方法的实现\n  export default {\n    data() {\n      return {\n      };\n    },\n    /**\n     * 组件名称，也就是开发者使用的标签\n     */\n    name: \"tusen-t-view\",\n    /**\n     * 组件涉及的事件声明，只有声明过的事件，才能被正常发送\n     */\n    emits: ['buttonclick'],\n    /**\n     * 属性声明，组件的使用者会传递这些属性值到组件\n     */\n    props: {\n      /**\n       * 字符串类型 属性：buttontext  需要设置默认值\n       */\n      \"buttontext\": {\n        type: String,\n        default: \"点击触发\"\n      }\n    },\n    /**\n     * 组件内部变量声明\n     */\n\n    /**\n     * 属性变化监听器实现\n     */\n    watch: {\n      \"buttontext\": {\n        /**\n         * 这里监听属性变化，并进行组件内部更新\n         */\n        handler(newValue : String, oldValue : String) {\n          this.$el.setTitle(newValue, for = UIControl.State.normal)\n        },\n        /**\n         * 创建时是否通过此方法更新属性，默认值为false\n         */\n        immediate: false\n      },\n    },\n    /**\n     * 规则：如果没有配置expose，则methods中的方法均对外暴露，如果配置了expose，则以expose的配置为准向外暴露\n     * ['publicMethod'] 含义为：只有 `publicMethod` 在实例上可用\n     */\n    expose: ['doSomething'],\n    methods: {\n      /**\n       * 对外公开的组件方法\n       * 在uni-app中调用组件方法，可以通过指定ref的方式，例如指定uts-button 标签的ref 为 ’button‘， 调用时使用：this.$refs[\"button\"].doSomething('message');\n       */\n      doSomething(paramA : string) {\n        // 这是组件的自定义方法\n        console.log(paramA, 'this is in uts-button component')\n      },\n\n\n      /**\n       * 内部使用的组件方法\n       */\n    },\n\n\n    /**\n     * 组件被创建，组件第一个生命周期，\n     * 在内存中被占用的时候被调用，开发者可以在这里执行一些需要提前执行的初始化逻辑\n     * [可选实现]\n     */\n    created() {\n\n    },\n    /**\n     * 对应平台的view载体即将被创建，对应前端beforeMount\n     * [可选实现]\n     */\n    NVBeforeLoad() {\n\n    },\n    /**\n     * 创建原生View，必须定义返回值类型\n     * 开发者需要重点实现这个函数，声明原生组件被创建出来的过程，以及最终生成的原生组件类型\n     * [必须实现]\n     */\n    NVLoad() : UIButton {\n      //必须实现\n      buttonClickListsner = new ButtonClickListsner(this)\n\n      let button = new UIButton()\n      button.setTitle(this.buttontext, for = UIControl.State.normal)\n      // 在 swift target-action 对应的方法需要以OC的方式来调用，那么OC语言中用Selector来表示一个方法的名称（又称方法选择器），创建一个Selector可以使用 Selector(\"functionName\") 的方式。\n      const method = Selector(\"buttonClickAction\")\n      if (buttonClickListsner != null) {\n        button.addTarget(buttonClickListsner!, action = method, for = UIControl.Event.touchUpInside)\n      }\n      return button\n    },\n\n    /**\n     * 原生View已创建\n     * [可选实现]\n     */\n    NVLoaded() {\n      /**\n       * 通过 this.$el 来获取原生控件。\n       */\n      this.$el.setTitle(this.buttontext, for = UIControl.State.normal)\n    },\n    /**\n     * 原生View布局完成\n     * [可选实现]\n     */\n    NVLayouted() {\n\n    },\n    /**\n     * 原生View将释放\n     * [可选实现]\n     */\n    NVBeforeUnload() { },\n    /**\n     * 原生View已释放，这里可以做释放View之后的操作\n     * [可选实现]\n     */\n    NVUnloaded() {\n\n    },\n    /**\n     * 组件销毁\n     * [可选实现]\n     */\n    unmounted() { }\n\n    /**\n     * 更多组件开发的信息详见：https://uniapp.dcloud.net.cn/plugin/uts-component.html\n     */\n  }\n\n  /**\n   * 定义按钮点击后触发回调的类\n   * [可选实现]\n   */\n  class ButtonClickListsner {\n    /**\n     * 如果需要在回调类或者代理类中对组件进行操作，比如调用组件方法，发送事件等，需要在该类中持有组件对应的原生类的对象。\n     * 组件原生类的基类为 UTSComponent，该类是一个泛型类，需要接收一个类型变量，该类型变量就是原生组件的类型。\n     */\n    private component : UTSComponent<UIButton>\n\n    constructor(component : UTSComponent<UIButton>) {\n      this.component = component\n      super.init()\n    }\n\n    /**\n     * 按钮点击回调方法\n     * 在 swift 中，所有target-action (例如按钮的点击事件，NotificationCenter 的通知事件等)对应的 action 函数前面都要使用 @objc 进行标记。\n     * [可选实现]\n     */\n    @objc buttonClickAction() {\n      console.log(\"按钮被点击\")\n      // 发送事件\n      this.component.__$$emit(\"buttonclick\");\n    }\n  }\n\n  /**\n   * 定义回调类或者代理类的实例\n   * [可选实现]\n   */\n  let buttonClickListsner : ButtonClickListsner | null = null\n\n\n\n\n\n"],"names":[],"mappings":"AA6BE,0BAAkD;AApBlD,YAGc;;;gDA4GD;oCAlEE;mCAmDH,CAEV;wCAKe,CAEf;qCAMW,SAAS;QAElB,sBAAsB,AAAI,oBAAoB,IAAI;QAElD,IAAI,SAAS,AAAI;QACjB,OAAO,QAAQ,CAAC,IAAI,CAAC,UAAU,EAAE,KAAM,UAAU,KAAK,CAAC,MAAM;QAE7D,IAAM,SAAS,SAAS;QACxB,IAAI,uBAAuB,GAAI,EAAE;YAC/B,OAAO,SAAS,CAAC,sBAAsB,QAAS,QAAQ,KAAM,UAAU,KAAK,CAAC,aAAa;QAC7F;QACA,OAAO;IACT;oCAMW;QAIT,IAAI,CAAC,MAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,EAAE,KAAM,UAAU,KAAK,CAAC,MAAM;IACjE;sCAKa,CAEb;0CAKiB,CAAE;sCAKN,CAEb;qCAKY,CAAE;4BA/EA,EAAA,QAAS,MAAM,EAAE;QAE3B,QAAQ,GAAG,CAAC,QAAQ;IACtB;;;;;;;YAtBU;YAAmB;QACzB,IAAI,CAAC,MAAG,CAAC,QAAQ,CAAC,UAAU,KAAM,UAAU,KAAK,CAAC,MAAM;;;;AA4GhE;;aAAM;IAKJ,YAAQ,WAAY,aAAa,SAAS;IAE1C,YAAY,EAAA,WAAY,aAAa,SAAS,CAAE;QAC9C,IAAI,CAAC,SAAS,GAAG;QACjB,KAAK,CAAC,IAAI;IACZ;IAOA,CAAC;IAAI,YAAC,oBAAoB;QACxB,QAAQ,GAAG,CAAC;QAEZ,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;IAC1B;AACF;AAMA,WAAI,qBAAsB,uBAA6B,GAAI"}